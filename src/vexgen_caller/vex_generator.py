import os
import requests
import json
import zipfile
from utils.file_writer import make_valid_file_path as sanitize_path, generate_path_repo
from utils.request_helper import authenticated_request
from database.models import Artifact, Vulnerability
import shutil
from pathlib import Path

def generate_download_path(owner:str, name:str) -> str:
    folder_name = f"{owner}/{name}"
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
    general_vex_path = os.path.join(project_root, "generated_vex")
    return sanitize_path(folder_name, general_vex_path)

def generate_vex(owner:str, name:str):
    url = os.getenv("VEXGEN_URL") + "vexgen/vex_tix/generate"
    if not owner or not name:
        raise ValueError("Owner, name and SBOM path must be provided for VEX generation.")
    
    # Get user ID from json file
    token_file = os.path.expanduser(os.getenv("VEXGEN_TOKEN_FILE"))
    if not os.path.exists(token_file):
        raise FileNotFoundError(f"Token file not found: {token_file}")
    with open(token_file, 'r') as f:
        token_data = json.load(f)
        token = token_data.get("token")
        refresh_token = token_data.get("refresh_token")
        user_id = token_data.get("user_id")
        if not user_id:
            raise ValueError("User ID must be provided or found in the token file.")
        if not token:
            raise ValueError("Token must be provided or found in the token file.")
        if not refresh_token:
            raise ValueError("Refresh token must be provided or found in the token file.")
        
    
    data = {
        "owner": owner,
        "name": name,
        "user_id": user_id
    }
    
    try:
        response = authenticated_request("POST", url, token, refresh_token, data)
        response.raise_for_status()
        print("Vex generation successful.")
        # Check if response contains a file (zip)
        content_type = response.headers.get('content-type', '')
        if 'application/zip' in content_type:
            # Extract filename from content-disposition header
            content_disposition = response.headers.get('content-disposition')
            filename = 'vex_tix_sbom.zip'
            if 'filename=' in content_disposition:
                filename = content_disposition.split('filename=')[1].strip('"')
            
            # Create directory structure
            download_path = generate_download_path(owner, name)

            if os.path.exists(download_path):
                # Directory exists, clear its contents
                shutil.rmtree(download_path)
            
            # Create directory
            os.makedirs(download_path, exist_ok=True)

            # Full path for the zip file
            zip_path = os.path.join(download_path, filename)

            # Save the file
            with open(zip_path, 'wb') as f:
                f.write(response.content)
            # Extract zip file
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(download_path)
            print(f"TIX file downloaded to: {download_path}")

            # Remove the zip file after extraction
            os.remove(zip_path)
            
            # Remove extrafiles to only get one tix
            tix_found = False
            for item in os.listdir(download_path):
                item_path = os.path.join(download_path, item)
                if os.path.isfile(item_path):
                    if not tix_found and item.startswith('tix'):
                        tix_found = True
                    else:
                        os.remove(item_path)            
        else:
            raise ValueError("Response does not contain a valid VEX file: " + response.json().get('message', 'Unknown error'))
    except requests.RequestException as e:
        print(f"Error generating TIX: {response.json().get('detail', 'Unknown error')}")


def get_tix_data(owner:str, name:str) -> (tuple[list[Vulnerability], str]):
    """
    Opens the TIX file generated by VEXGEN, extract vulnerabilities and artifacts info and store them in the database.
    """
    repo_path = Path(generate_path_repo(owner, name))
    statements = open_tix_file(owner, name, repo_path)

    artifacts_dict = {}
    vulnerabilities = []
    # After migrating to TIX instead of VEX, each statement is equivalent to a vulnerability
    for statement in statements:
        reachable_code = statement.get("reachable_code")
        
        # If reachable_code is present, there is a possible vulnerable artifact
        if reachable_code:
            vulnerability_data = statement.get("vulnerability")
            if vulnerability_data:
                vulnerability = Vulnerability()
                vulnerability.name = vulnerability_data.get("name")
                cvss = vulnerability_data.get("cvss")
                vulnerability.impact = cvss.get("vuln_impact", 0.0)
                vulnerability.attackVector = cvss.get("attack_vector", "UNKNOWN")
                
            for file in reachable_code:
                
                file_path = file.get("path_to_file")
                if file_path and file_path.endswith('.java'):
                    used_artifacts = file.get("used_artefacts", [])
                    for artifact in used_artifacts:
                        artifact_name = artifact.get("artefact_name")
                        used_in_lines = artifact.get("used_in_lines", []).strip().split(',')
                        for line in used_in_lines:
                            # Only add if line is a number
                            try:
                                target_line = int(line)
                                # By default, vexgen provides repo path in the file_path, but in OSS-Fuzz we use another name to avoid conflicts
                                relative_path = Path(file_path)
                                relative_path = Path(*relative_path.parts[1:])
                                
                                artifact_data = Artifact(
                                    filePath=str(repo_path / relative_path),
                                    line=target_line,
                                    name=artifact_name
                                )
                                
                                # It is needed to ensure that the same artifact instance is used when storing in the database, to avoid duplicates
                                artifact_key = generate_artifact_key(artifact_data.filePath, artifact_data.name, artifact_data.line)
                                if artifact_key not in artifacts_dict:
                                    artifacts_dict[artifact_key] = artifact_data
                                    vulnerability.artifacts.add(artifact_data)
                                else:
                                    vulnerability.artifacts.add(artifacts_dict[artifact_key])

                            except Exception:
                                continue  # Skip if not a number
            vulnerabilities.append(vulnerability)
    artifacts = artifacts_json(artifacts_dict)
    return vulnerabilities, artifacts

def open_tix_file(owner:str, name:str, repo_path: str) -> str:
    """Open tix file and return its content as a dictionary"""
    generate_download_path(owner, name)

    tix_file = None
    # In case there are multiple tix files, take the first one
    for item in os.listdir(generate_download_path(owner, name)):
        if item.startswith("tix") and item.endswith(".json"):
            tix_file = item
            break

    if not tix_file:
        raise FileNotFoundError("TIX file not found in the expected directory.")

    tix_path = os.path.join(generate_download_path(owner, name), tix_file)
    if not os.path.exists(tix_path):
        raise FileNotFoundError(f"TIX file not found: {tix_path}")
    with open(tix_path, 'r') as f:
        tix_data = json.load(f)

    if not tix_data:
        raise ValueError("TIX data is empty or invalid.")

    return tix_data.get("statements", [])


def artifacts_json(artifacts: dict) -> str:
    """
    Converts a dictionary of artifacts to a JSON string.
    """
    artifacts_list = []
    for artifact in artifacts.values():
        artifacts_list.append({
            "file_path": str(artifact.filePath),
            "target_line": str(artifact.line),
            "target_name": artifact.name
        })
    
    # Return as JSON to use it on spoon
    return json.dumps(artifacts_list, indent=2)

    
    
    
def generate_artifact_key(file_path: str, name: str, line:int) -> str:
    """
    Generates a unique key for an artifact based on its file path, target line, and target name.
    """
    return f"{file_path}-{name}-{line}"